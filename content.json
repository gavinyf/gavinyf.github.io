{"meta":{"title":"Hexo","subtitle":"","description":"","author":"gavin","url":"http://esthery.cn","root":"/"},"pages":[],"posts":[{"title":"Flutter之Animation","slug":"Flutter之Animation","date":"2020-01-19T12:06:46.000Z","updated":"2020-01-19T12:07:40.078Z","comments":true,"path":"2020/01/19/Flutter之Animation/","link":"","permalink":"http://esthery.cn/2020/01/19/Flutter%E4%B9%8BAnimation/","excerpt":"","text":"在用户体验当中，设计巧妙的动画可以让UI体验更加的直观，而Flutter作为一个友好的跨平台框架对此作了很好的支持。接下来我将把我在这段时间学习的Flutter动画知识分享给大家，希望大家在学完之后对此可以有一个初步的了解。 基本概念首先，我简单表述下Flutter中动画的基本概念。动画中最核心的类是Animation&lt;T&gt;类。而这个类最基本的功能就是在一段时间里不停的“吐出”一定的值，而这个值可以通过对象的value属性获取的。而这个value的类型就是T，然后做动画的的widget根据获取到的value值不断地rubuild。这就是动画的基本原理。Animation&lt;T&gt;这个类的部分子类是有状态的，而所谓的状态，我的个人理解就是它自身是可以被监听的，那么该如何创建一个简单的动画呢?以下代码就是简单创建一个动画的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import &apos;package:flutter/material.dart&apos;;void main() =&gt; runApp(Animation1());class Animation1 extends StatefulWidget&#123; @override State&lt;StatefulWidget&gt; createState() &#123; // TODO: implement createState return _animation1State(); &#125;&#125;class _animation1State extends State&lt;Animation1&gt; with SingleTickerProviderStateMixin&#123; AnimationController controller; CurvedAnimation curve; Animation&lt;double&gt; animation; @override void initState() &#123; super.initState(); controller = AnimationController(vsync: this,duration: Duration(seconds: 2)); curve = CurvedAnimation(parent: controller,curve: Curves.bounceInOut); animation = Tween&lt;double&gt;(begin: 10,end: 200).animate(curve) ..addListener(()&#123; setState(() &#123; &#125;); &#125;) ..addStatusListener((state)&#123; if (state == AnimationStatus.completed) &#123; controller.reverse(); &#125;else if (state == AnimationStatus.dismissed)&#123; controller.forward(); &#125; &#125;); controller.forward(); &#125; @override Widget build(BuildContext context) &#123; // TODO: implement build return MaterialApp( title: &apos;AnimateApp&apos;, theme: ThemeData( primaryColor: Colors.redAccent ), home: Scaffold( appBar: AppBar( title: Text(&apos;AnimateApp&apos;), ), body: Center( child: Container( width: animation.value, height: animation.value, decoration: BoxDecoration( color: Colors.blue ), ), ), ), ) &#125; @override void dispose() &#123; // TODO: implement dispose controller.dispose(); super.dispose(); &#125; 上面提到了四个关键的类:AnimationController,CurvedAnimation,Tween&lt;double&gt;以及Animation&lt;double&gt;。接下来我们分别介绍这四个类。 AnimationController 这个继承是Animation类.是一个特殊的Animation对象，每当GPU重新绘制屏幕，准备新的帧的时候，他就会生成一个新值，而这个值的区间就是0.0到1.0，生成的速度默认情况是线性的。除了作为动画本身，她也可以控制动画，观察它的构造函数可以看出这个动画持续的时间是2秒，至于前面的vsync是为了在动画过程不绘制屏幕外的动画，只绘制屏幕以内可视区间的动画来保证资源的有效利用。 CurvedAnimation 这个类也是继承Animation类，看代码中的构造函数可以看出，这个类接受Animation&lt;double&gt;(父级)以及Curve类为输入，并使用父级的值作为输入提供给曲线来确定输出，这个类是无状态的不可变的，只是将父级的输入转化了一遍。 Tween&lt;double&gt; 这个类是继承Animatable的，而这个类的作用其实就是重新定义了begin和end的值的类型和范围，并通过animate()函数来返回一个新Animation子类。 Animation&lt;double&gt; 这个类是我们大部分情况所用到的，它自身是有状态的可以被监听的，默认的范围为0.0到1.0。在代码中通过Tween&lt;double&gt;这个类的映射改变了区间值，使其变成10到200的范围区间。然后通过addListener方法来不断的调用setState()方法rebuild widget达到动画的效果。下图简单显示了代码中的动画流程。 AnimatedWidget上面我们讲完了一个基本动画该如何创建，而在Animation类和Widget(要做动画的)之间最重要的桥接就是addListener()以及setState()方法，接下来我们将讲述另一种创建动画的方式而不需要显式的调用这两个方法。代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import &apos;package:flutter/material.dart&apos;;import &apos;package:flutter/animation.dart&apos;;void main() =&gt; runApp(animation2());class animation2 extends StatefulWidget &#123; animation2(&#123;Key key&#125;) : super(key: key); @override _animation2State createState() =&gt; _animation2State();&#125;class _animation2State extends State&lt;animation2&gt; with SingleTickerProviderStateMixin &#123; AnimationController controller; Animation&lt;double&gt; animation; @override void initState() &#123; // TODO: implement initState super.initState(); controller = AnimationController(vsync: this,duration: Duration(seconds: 2)); final CurvedAnimation curve = CurvedAnimation(parent: controller,curve: Curves.bounceInOut); animation = Tween&lt;double&gt;(begin: 0,end: 300).animate(curve); controller.forward(); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &apos;AnimationApp&apos;, theme: ThemeData( primaryColor: Colors.red ), home: Scaffold( appBar: AppBar( title: Text(&apos;AnimateApp&apos;), backgroundColor: Colors.brown, ), body: Center( child: Animation2Square(animation: animation), ), ) ); &#125;&#125;class Animation2Square extends AnimatedWidget&#123; Animation2Square(&#123;Key key, Animation&lt;double&gt; animation&#125;) :super(key:key,listenable:animation); @override Widget build(BuildContext context) &#123; final Animation&lt;double&gt; animation = listenable as Animation&lt;double&gt;; // TODO: implement build return Container( margin: EdgeInsets.symmetric(vertical: 10), width: animation.value, height: animation.value, decoration: BoxDecoration( color: Colors.blue ), ); &#125;&#125; Animation2Square继承自AnimatedWidget, 不需要保持State对象来hold动画，而是接受一个Listenable类型的参数，而Animation类本身就继承自这个类。可以不断的rebuild widget来执行动画。但是以上的代码有一个问题就是改变动画的时候需要改变渲染方块的widget。所以我们这里可以把任务分到不同的类中: 渲染方块 定义动画对象 渲染过渡效果 在这里我们就用到了AnimatedBuilder类。 AnimatedBuilder话不多说，先上代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import &apos;package:flutter/material.dart&apos;;import &apos;package:flutter/animation.dart&apos;;void main() =&gt; runApp(animation3());class animation3 extends StatefulWidget &#123; animation3(&#123;Key key&#125;) : super(key: key); @override _animation3State createState() =&gt; _animation3State();&#125;class _animation3State extends State&lt;animation3&gt; with SingleTickerProviderStateMixin&#123; AnimationController controller; Animation&lt;double&gt; animation; @override void initState() &#123; // TODO: implement initState super.initState(); controller = AnimationController(vsync: this,duration: Duration(seconds: 4)); animation = Tween&lt;double&gt;(begin: 20,end: 300).animate(controller) ..addStatusListener((state)&#123; if (state == AnimationStatus.completed) &#123; controller.reverse(); &#125;else if (state == AnimationStatus.dismissed)&#123; controller.forward(); &#125; &#125;); controller.forward(); &#125; @override Widget build(BuildContext context) &#123; return MaterialApp( title: &quot;AnimationApp&quot;, theme: ThemeData( primaryColor: Colors.red, ), home: Scaffold( appBar: AppBar( title: Text(&apos;AnimationApp&apos;), backgroundColor: Colors.brown, ), body: Center( child: GrowTranstion(animation: animation,animationWidget: animation3Squal()), ), ), ); &#125;&#125;class GrowTranstion extends StatelessWidget &#123; GrowTranstion(&#123;this.animation,this.animationWidget&#125;); final Widget animationWidget; final Animation&lt;double&gt; animation; @override Widget build(BuildContext context) &#123; return Center( child: AnimatedBuilder( animation: animation, child: animationWidget, builder: (BuildContext context, Widget child) &#123; return Container( width: animation.value, height: animation.value, child: animationWidget, ); &#125;, ), ); &#125;&#125;class animation3Squal extends StatelessWidget &#123; Widget build(BuildContext context) =&gt; Container( margin: EdgeInsets.symmetric(vertical: 10), child: Container(), decoration: BoxDecoration( color: Colors.blue ), );&#125; 在上述代码中，我们将动画本身以及做动画的widget分开。新建了一个GrowTranstion对象来桥接这两个对象，然后在build方法中返回AnimatedBuilder来渲染以达到动画的效果。 总结 Flutter中的动画的核心类是Animation。而一个动画的变现的形式就是在它的生命周期内发生变化的特定类型的值。 大多数的需要执行动画的widgets都需要接受一个Animation对象作为参数。从而能够获取动画当前的值以及应该监听哪些值的修改。","categories":[],"tags":[]},{"title":"Dart之异步","slug":"Dart之异步","date":"2019-12-09T08:35:39.000Z","updated":"2019-12-09T08:42:38.838Z","comments":true,"path":"2019/12/09/Dart之异步/","link":"","permalink":"http://esthery.cn/2019/12/09/Dart%E4%B9%8B%E5%BC%82%E6%AD%A5/","excerpt":"","text":"在iOS开发过程中，我们经常会需要操作一些耗时操作，比如网络请求，从本地数据库读取数据等。而我们经常用到的方法就是开启一个子线程，将这些操作放到这个子线程里面操作，而不影响主线程的性能，当这些操作有返回的时候再回到主线程进行页面的刷新等。但是在Dart开发中，是没有多线程这个概念的，只有单线程，那么在处理一些耗时较长的操作的时候，Dart是如何处理的呢？ Dart中的单线程isolate在Dart开发中，并没有像其他语言中的多线程的概念，而是多了一个类似的isolate概念。它有独立内存空间，也有一条时刻都在处理数据的事件处理循环(event loop)。我们可以把它看成有独立空间的线程。如下图所示，绿色的格子空间代表内存。红色箭头代表event loop。 当然了，我们也可以自己创建一个新的isolate，用Isolate.spawn() 或者 Flutter’s compute()的方式，新创建出来的isolate有自己的内存空间和event loop.而两个isolate之间的信息传递只能通过其他特殊的方式。 event loopDart中的事件处理有很多，如触摸处理，网络数据处理，滑动处理等，都需要交给event loop来处理。 上图左侧的不同颜色的多边形代表的就是需要处理的不同类型的事件，右边代表的就是event loop。 Dart中的异步操作future说到Dart的异步操作就不能不提到一个名词：future。 那么什么是future呢？future本质上就是一个对象，但这个对象呢？有两种状态，一种是Uncompleted状态，一种是Completed的状态，而Completed的状态又分为两种，一种是真实的value值，一直就是通用的error。举个很简单的例子：Future&lt; String &gt; 这个类所对应的value值就是字符串。如下图所示：我来举个例子，假如现在我们点击一个按钮，然后去发起请求一张图片的网络请求，然后再把这张图片显示出来。这是我们平时遇到最多的需要进行异步加载的情形，代码如下： 123456789RaisedButton( onPressed: () &#123; final myFuture = http.get(&apos;https://my.image.url&apos;); myFuture.then((resp) &#123; setImage(resp); &#125;); &#125;, child: Text(&apos;Click me!&apos;),) 接下里我们来拆分这个问题： 按钮点击。 发送请求。 请求返回，处理数据。 我们要完成这个操作是需要三步的，而在我们的event loop中就属于三个不同的event需要处理。我们处理异步这个关键的地方就是我们要说的future对象。在我们发出处理完第二步的时候，event loop会给我们返回一个盒子，盒子里是啥我们不知道，然后再第三步数据返回的时候，event loop会将一张图片放在这个盒子里面，如果你想处理这张图片，那么你就的注册一下then这个block。在这个block里面对返回的图片进行操作。在这个例子当中，这个盒子就是我们上文提到的future。在这个这个value就是那张图片。如何创建future呢？目前主要有两种方式可以得到future，一种就是系统的api，比如http网络请求库,我们上面的代码。另一种方式就是我们自己创建，代码如下: 12345void main() &#123; final myFuture = Future(() &#123; return 12; &#125;);&#125; 或者 123void main() &#123; final myFuture = Future.value(12);&#125; 我们除了可以创建有值的future的话还可以模拟创建包含错误的future： 123void main() &#123; final myFuture = Future.error(ArgumentError.notNull(&apos;input&apos;));&#125; 我们在上面第一段代码里面再加一句话来更加详细说明一下异步操作的过程。 1234567void main() &#123; final myFuture = Future(() &#123; print(&apos;Creating the future.&apos;); // 2. return 12; &#125;); print(&apos;Done with main().&apos;); // 1.&#125; 以上代码后一句会先打印，而前一句会后打印，为什么呢？就像我们之前说的那样，Dart本身是单线程的，所以需要进行的操作都是一个一个接着放入event loop中进行。Future用构造函数创建的时候，一开始返回的其实就是一个uncompleted future，就好比如说是：“你好，这里有一个封闭的箱子，你先拿着，待会我会放点东西进去，然后你再打开”，就是这么简单。这是第一个需要处理的event，然后接下来进行的是print(&#39;Done with main().&#39;);这句代码。再然后呢？我们就放了一个为12的数据进去了。有时候网络请求返回的可能是个错误，也就是说我们手里拿着的这个盒子里面的东西不是我们真正想要的值，那我们该怎么办呢？我们可以跟处理正常的value一样，注册一个block来处理，代码如下： 1234567891011void main() &#123; Future.delayed( Duration(seconds: 3), () =&gt; throw &apos;Error!&apos;, // 放个error进盒子里. ).then((value) &#123; print(value); &#125;).catchError((err) &#123; print(&apos;Caught $err&apos;); // 处理这个错误. &#125;); print(&apos;Waiting for a value...&apos;);&#125; 还有一种block，我们可以注册，那就是当future盒子里面有东西了，无论这个东西是个值还是个错误。如： 123456789101112void main() &#123; Future.delayed( Duration(seconds: 3), () =&gt; throw &apos;Error!&apos;, // 放个error进盒子里. ).then((value) &#123; print(value); &#125;).catchError((err) &#123; print(&apos;Caught $err&apos;); // 处理这个错误. &#125;).whenComplete()&#123; print(&apos;完成了！&apos;); &#125;; &#125; 说到了这里，我们大致弄清楚了Dart异步操作的一些基本原理和简单操作，那么为什么我们还需要await和async呢？ await和async我们通过一个比较简单的例子来阐述下为什么我们需要用到await和async，以及用这两个关键词的好处。假设我们现在有三个操作，分别是从本地数据库取用户id，然后再用这个用户id去远程服务器上获取对应的用户数据，最后我们再对这个获取到的用户数据进行处理显示在界面上： 123getIDFromDisk（）//从本地获取用户idFetchDataFromNetWorkWithId（String id）//根据id去远程服务器取用户数据processData() 处理数据 由于前两个操作都是耗时的操作，所以我们会用到future这个对象。伪完整的代码如下： 1234567Future&lt;ProcessData&gt; createData()&#123; return getIDFromDisk().then((id)&#123; return FetchDataFromNetWorkWithId(id) &#125;).then((data)&#123; return ProcessData(data); &#125;); &#125; 上述代码看上去是不是很复杂，这样还挺好的，没有对返回的错误进行注册处理。而且这还只是两个耗时的操作，就得注册两个then() 的回调。如果是多个呢？那么代码的可读性就会很差。这个时候我们为了代码看起来可读性更好的时候，并且让异步的代码看起来像同步一样，await和async就发挥出作用了在运用这两个关键字之前，我们先简单的说明几个概念： 同步操作：一个同步操作会阻塞其他操作，直到它完成。 同步方法：一个同步方法里只能执行同步操作。 异步操作：一旦调用成功，一个异步操作可以允许其他操作在其没完成的时候执行。 异步方法：一个异步方法里面不仅可以执行同步操作，也可以执行异步操作。 根据官网的解释，await和async的基本用法如下： async是为了将方法标注为异步方法。 而await只能用在异步方法中(async标注的方法) 1void main() async &#123; ··· &#125; 如果有返回值的话 1Future&lt;void&gt; main() async &#123; ··· &#125; 而await主要就是放在调用的异步方法前，如 1await createOrderMessage() 我们现在将之前的代码用await和async重新写一遍： 123456Future&lt;ProcessData&gt; createData() async&#123; String id = await getIDFromDisk(); Data data = await FetchDataFromNetWorkWithId(id) return ProcessData(data); &#125; 这样看上去是要简洁了许多，并且看上去像是在同步调用一样。 总结 Dart中没有多线程的概念，而是isolate。 Dart中处理事件的方式是event loop。 为了可以做到异步操作，Dart引入了future对象，也就是盒子概念。 await和async的引入是为了让异步操作看上去像同步操作，且提高代码的可读性。","categories":[],"tags":[]}]}